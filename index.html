<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Slime Game with AI</title>
<style>
  body {
    background: #222;
    color: #fff;
    font-family: Arial, sans-serif;
    margin: 0;
    overflow: hidden;
  }
  #gameCanvas {
    display: block;
    margin: auto;
    background: #111;
    border: 2px solid #888;
  }
  #ui {
    position: absolute;
    top: 10px; left: 10px;
    z-index: 10;
    font-size: 18px;
  }
  #buttons {
    position: absolute;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
  }
  button {
    margin: 0 5px;
    padding: 10px 15px;
    font-size: 16px;
  }
</style>
</head>
<body>
  <div id="ui">
    HP: <span id="playerHp">100</span> | Boss HP: <span id="bossHp">300</span> | Current Arrow: <span id="arrowType">Normal</span>
  </div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="buttons">
    <button id="btnLeft">Left</button>
    <button id="btnRight">Right</button>
    <button id="btnShoot">Shoot</button>
    <button id="btnChangeArrow">Change Arrow</button>
  </div>

  <script src="game.js"></script>
  <script src="ai.js"></script>
</body>
</html>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const player = {
  x: 200,
  y: 550,
  size: 20,
  color: "cyan",
  hp: 100,
  speed: 5,
  arrowTypes: ["Normal", "Fire", "Ice"],
  currentArrowIndex: 0,
};

const boss = {
  x: 200,
  y: 100,
  size: 60,
  color: null, // gradient handled in drawBoss
  hp: 300,
  moveSpeed: 2,
  attackTimer: 0,
  isInvincible: false,
};

let slimes = [];
let attacks = [];
let arrows = [];

function createSlimes(count = 5) {
  for (let i = 0; i < count; i++) {
    slimes.push({
      x: Math.random() * canvas.width,
      y: Math.random() * (canvas.height / 2),
      size: 15,
      color: "lime",
      speed: 1 + Math.random() * 1.5,
      hp: 30,
      attackCooldown: 0,
    });
  }
}

function drawPlayer() {
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
  ctx.fill();

  // Draw bow (simple line)
  ctx.strokeStyle = "brown";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(player.x - 5, player.y);
  ctx.lineTo(player.x + 15, player.y - 10);
  ctx.stroke();
}

function drawBoss() {
  // Rainbow gradient
  const gradient = ctx.createLinearGradient(boss.x - boss.size, boss.y, boss.x + boss.size, boss.y);
  gradient.addColorStop(0, "red");
  gradient.addColorStop(0.15, "orange");
  gradient.addColorStop(0.3, "yellow");
  gradient.addColorStop(0.5, "green");
  gradient.addColorStop(0.65, "blue");
  gradient.addColorStop(0.8, "indigo");
  gradient.addColorStop(1, "violet");
  ctx.fillStyle = boss.isInvincible ? "gray" : gradient;

  ctx.beginPath();
  ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI * 2);
  ctx.fill();

  // Boss HP bar
  ctx.fillStyle = "red";
  ctx.fillRect(boss.x - 50, boss.y - boss.size - 20, 100 * (boss.hp / 300), 10);
  ctx.strokeStyle = "white";
  ctx.strokeRect(boss.x - 50, boss.y - boss.size - 20, 100, 10);
}

function drawSlimes() {
  slimes.forEach(s => {
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawArrows() {
  arrows.forEach(a => {
    ctx.fillStyle = a.color;
    ctx.beginPath();
    ctx.rect(a.x - 2, a.y - 5, 4, 10);
    ctx.fill();
  });
}

function drawAttacks() {
  attacks.forEach(atk => {
    ctx.fillStyle = atk.color || "rgba(255,0,0,0.5)";
    ctx.beginPath();
    ctx.arc(atk.x, atk.y, atk.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function movePlayerLeft() {
  player.x = Math.max(player.size, player.x - player.speed);
}

function movePlayerRight() {
  player.x = Math.min(canvas.width - player.size, player.x + player.speed);
}

function shootArrow() {
  const type = player.arrowTypes[player.currentArrowIndex];
  let color = "white";
  let speed = 10;
  let damage = 10;

  if (type === "Fire") {
    color = "orange";
    damage = 15;
  } else if (type === "Ice") {
    color = "skyblue";
    damage = 8;
  }

  arrows.push({
    x: player.x,
    y: player.y - player.size,
    size: 5,
    speed: speed,
    damage: damage,
    color: color,
    type: type,
  });
}

function changeArrow() {
  player.currentArrowIndex = (player.currentArrowIndex + 1) % player.arrowTypes.length;
  document.getElementById("arrowType").textContent = player.arrowTypes[player.currentArrowIndex];
}

function updateArrows() {
  arrows.forEach((a, i) => {
    a.y -= a.speed;
    if (a.y < -10) arrows.splice(i, 1);

    // Check collision with boss
    let dx = a.x - boss.x;
    let dy = a.y - boss.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < boss.size + a.size && boss.hp > 0 && !boss.isInvincible) {
      boss.hp -= a.damage;
      arrows.splice(i, 1);
    }

    // Check collision with slimes
    slimes.forEach((s, si) => {
      let dxs = a.x - s.x;
      let dys = a.y - s.y;
      let distS = Math.sqrt(dxs*dxs + dys*dys);
      if (distS < s.size + a.size) {
        s.hp -= a.damage;
        arrows.splice(i, 1);
        if (s.hp <= 0) slimes.splice(si, 1);
      }
    });
  });
}

function update() {
  updateArrows();

// ai.js

// 잡몹 배열과 생성 타이머
let monsters = [];
let monsterSpawnTimer = 0;

// 몬스터 생성 함수
function spawnMonster() {
  monsters.push({
    x: Math.random() * (canvas.width - 40) + 20,
    y: -30,
    size: 15,
    color: "purple",
    speed: 1.2,
    hp: 10,
  });
}

// 잡몹 이동 및 공격
function updateMonsters() {
  monsterSpawnTimer++;
  if (monsterSpawnTimer > 150) { // 약 2.5초마다 생성
    monsterSpawnTimer = 0;
    spawnMonster();
  }

  monsters.forEach((mon, i) => {
    // 플레이어 쫓아가기 (y 방향도 포함)
    let dx = player.x - mon.x;
    let dy = player.y - mon.y;
    let dist = Math.sqrt(dx * dx + dy * dy);
    let angle = Math.atan2(dy, dx);

    if (dist > mon.size + player.size + 5) {
      mon.x += Math.cos(angle) * mon.speed;
      mon.y += Math.sin(angle) * mon.speed;
    } else {
      // 플레이어와 너무 가까우면 공격 (체력 감소)
      if (player.hp > 0) player.hp -= 0.5;
    }

    // 몬스터가 죽으면 배열에서 제거
    if (mon.hp <= 0) monsters.splice(i, 1);
  });
}

// 보스 움직임 업데이트
let bossMoveCooldown = 0;
function updateBossMovement() {
  if (!boss.moveDir) boss.moveDir = 1;
  if (!boss.moveSpeed) boss.moveSpeed = 1.2;

  boss.x += boss.moveSpeed * boss.moveDir;
  bossMoveCooldown++;

  // 벽 만나면 방향 전환
  if (boss.x > canvas.width - boss.size) boss.moveDir = -1;
  if (boss.x < boss.size) boss.moveDir = 1;

  // 가끔 속도 변경 또는 잠깐 멈춤
  if (bossMoveCooldown > 180) { // 3초마다
    bossMoveCooldown = 0;
    let rand = Math.random();
    if (rand < 0.3) boss.moveSpeed = 0; // 잠깐 멈춤
    else boss.moveSpeed = 1 + Math.random(); // 속도 변화 1~2
  }
}

// 보스 공격 업데이트
function updateBossAttack() {
  boss.attackTimer++;
  if (boss.attackTimer > 120) {
    boss.attackTimer = 0;
    attacks.push({
      x: boss.x,
      y: boss.y + boss.size + 20,
      size: 30,
      color: "rgba(255, 0, 0, 0.5)",
      timer: 60,
    });
  }

  attacks.forEach((atk, i) => {
    atk.timer--;
    if (atk.timer <= 0) attacks.splice(i, 1);

    // 플레이어 피해 체크
    let dx = player.x - atk.x;
    let dy = player.y - atk.y;
    let dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < atk.size + player.size) {
      player.hp -= 1;
    }
  });
}
