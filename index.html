<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Slime Game with AI</title>
<style>
  body {
    background: #222;
    color: #fff;
    font-family: Arial, sans-serif;
    margin: 0;
    overflow: hidden;
  }
  #gameCanvas {
    display: block;
    margin: auto;
    background: #111;
    border: 2px solid #888;
  }
  #ui {
    position: absolute;
    top: 10px; left: 10px;
    z-index: 10;
    font-size: 18px;
  }
  #buttons {
    position: absolute;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
  }
  button {
    margin: 0 5px;
    padding: 10px 15px;
    font-size: 16px;
  }
</style>
</head>
<body>
  <div id="ui">
    HP: <span id="playerHp">100</span> | Boss HP: <span id="bossHp">300</span> | Current Arrow: <span id="arrowType">Normal</span>
  </div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="buttons">
    <button id="btnLeft">Left</button>
    <button id="btnRight">Right</button>
    <button id="btnShoot">Shoot</button>
    <button id="btnChangeArrow">Change Arrow</button>
  </div>

  <script src="game.js"></script>
  <script src="ai.js"></script>
</body>
</html>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const player = {
  x: 200,
  y: 550,
  size: 20,
  color: "cyan",
  hp: 100,
  speed: 5,
  arrowTypes: ["Normal", "Fire", "Ice"],
  currentArrowIndex: 0,
};

const boss = {
  x: 200,
  y: 100,
  size: 60,
  color: null, // gradient handled in drawBoss
  hp: 300,
  moveSpeed: 2,
  attackTimer: 0,
  isInvincible: false,
};

let slimes = [];
let attacks = [];
let arrows = [];

function createSlimes(count = 5) {
  for (let i = 0; i < count; i++) {
    slimes.push({
      x: Math.random() * canvas.width,
      y: Math.random() * (canvas.height / 2),
      size: 15,
      color: "lime",
      speed: 1 + Math.random() * 1.5,
      hp: 30,
      attackCooldown: 0,
    });
  }
}

function drawPlayer() {
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
  ctx.fill();

  // Draw bow (simple line)
  ctx.strokeStyle = "brown";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(player.x - 5, player.y);
  ctx.lineTo(player.x + 15, player.y - 10);
  ctx.stroke();
}

function drawBoss() {
  // Rainbow gradient
  const gradient = ctx.createLinearGradient(boss.x - boss.size, boss.y, boss.x + boss.size, boss.y);
  gradient.addColorStop(0, "red");
  gradient.addColorStop(0.15, "orange");
  gradient.addColorStop(0.3, "yellow");
  gradient.addColorStop(0.5, "green");
  gradient.addColorStop(0.65, "blue");
  gradient.addColorStop(0.8, "indigo");
  gradient.addColorStop(1, "violet");
  ctx.fillStyle = boss.isInvincible ? "gray" : gradient;

  ctx.beginPath();
  ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI * 2);
  ctx.fill();

  // Boss HP bar
  ctx.fillStyle = "red";
  ctx.fillRect(boss.x - 50, boss.y - boss.size - 20, 100 * (boss.hp / 300), 10);
  ctx.strokeStyle = "white";
  ctx.strokeRect(boss.x - 50, boss.y - boss.size - 20, 100, 10);
}

function drawSlimes() {
  slimes.forEach(s => {
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawArrows() {
  arrows.forEach(a => {
    ctx.fillStyle = a.color;
    ctx.beginPath();
    ctx.rect(a.x - 2, a.y - 5, 4, 10);
    ctx.fill();
  });
}

function drawAttacks() {
  attacks.forEach(atk => {
    ctx.fillStyle = atk.color || "rgba(255,0,0,0.5)";
    ctx.beginPath();
    ctx.arc(atk.x, atk.y, atk.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function movePlayerLeft() {
  player.x = Math.max(player.size, player.x - player.speed);
}

function movePlayerRight() {
  player.x = Math.min(canvas.width - player.size, player.x + player.speed);
}

function shootArrow() {
  const type = player.arrowTypes[player.currentArrowIndex];
  let color = "white";
  let speed = 10;
  let damage = 10;

  if (type === "Fire") {
    color = "orange";
    damage = 15;
  } else if (type === "Ice") {
    color = "skyblue";
    damage = 8;
  }

  arrows.push({
    x: player.x,
    y: player.y - player.size,
    size: 5,
    speed: speed,
    damage: damage,
    color: color,
    type: type,
  });
}

function changeArrow() {
  player.currentArrowIndex = (player.currentArrowIndex + 1) % player.arrowTypes.length;
  document.getElementById("arrowType").textContent = player.arrowTypes[player.currentArrowIndex];
}

function updateArrows() {
  arrows.forEach((a, i) => {
    a.y -= a.speed;
    if (a.y < -10) arrows.splice(i, 1);

    // Check collision with boss
    let dx = a.x - boss.x;
    let dy = a.y - boss.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < boss.size + a.size && boss.hp > 0 && !boss.isInvincible) {
      boss.hp -= a.damage;
      arrows.splice(i, 1);
    }

    // Check collision with slimes
    slimes.forEach((s, si) => {
      let dxs = a.x - s.x;
      let dys = a.y - s.y;
      let distS = Math.sqrt(dxs*dxs + dys*dys);
      if (distS < s.size + a.size) {
        s.hp -= a.damage;
        arrows.splice(i, 1);
        if (s.hp <= 0) slimes.splice(si, 1);
      }
    });
  });
}

function update() {
  updateArrows();

  // AI 업데이트는 ai.js에서 처리
  updateSlimes();
  updateBossMovement();
  updateBossAttack();

  // 게임 오버 체크
  if (player.hp <= 0) {
    alert("Game Over!");
    window.location.reload();
  }
  if (boss.hp <= 0) {
    alert("You Win!");
    window.location.reload();
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPlayer();
  drawBoss();
  drawSlimes();
  drawArrows();
  drawAttacks();

  // 플레이어 HP UI
  document.getElementById("playerHp").textContent = player.hp;
  document.getElementById("bossHp").textContent = boss.hp;
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

createSlimes(7);

document.getElementById("btnLeft").onclick = movePlayerLeft;
document.getElementById("btnRight").onclick = movePlayerRight;
document.getElementById("btnShoot").onclick = shootArrow;
document.getElementById("btnChangeArrow").onclick = changeArrow;

gameLoop();
function updateSlimes() {
  slimes.forEach((s) => {
    // 플레이어 방향으로 이동
    let dx = player.x - s.x;
    let dy = player.y - s.y;
    let dist = Math.sqrt(dx*dx + dy*dy);

    if (dist > s.size + player.size + 10) {
      s.x += (dx / dist) * s.speed;
      s.y += (dy / dist) * s.speed;
    } else {
      // 근접 공격 시도
      if (!s.attackCooldown || s.attackCooldown <= 0) {
        player.hp -= 5;
        s.attackCooldown = 60;
      }
    }
    if (s.attackCooldown > 0) s.attackCooldown--;
  });
}

function updateBossMovement() {
  // 보스는 좌우로 천천히 움직임 (무작위 방향)
  if (!boss.moveDir) boss.moveDir = 1;
  boss.x += boss.moveSpeed * boss.moveDir;
  if (boss.x > canvas.width - boss.size) boss.moveDir = -1;
  if (boss.x < boss.size) boss.moveDir = 1;
}

function updateBossAttack() {
  boss.attackTimer++;
  if (boss.attackTimer > 120) {
    boss.attackTimer = 0;
    // 공격 패턴 생성 (간단히 공격 범위 생성)
    attacks.push({
      x: boss.x,
      y: boss.y + boss.size + 20,
      size: 30,
      color: "rgba(255, 0, 0, 0.5)",
      timer: 60,
    });
  }

  attacks.forEach((atk, i) => {
    atk.timer--;
    if (atk.timer <= 0) attacks.splice(i, 1);

    // 플레이어가 공격 범위 안에 있으면 피해
    let dx = player.x - atk.x;
    let dy = player.y - atk.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < atk.size + player.size) {
      player.hp -= 1;
    }
  });
}
