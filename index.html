<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Slime RPG with Boss & Weapons</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0; padding: 0;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    body {
      background-color: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      margin: auto;
      background: #111;
      border: 2px solid #888;
      touch-action: none;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      z-index: 10;
    }
    #ui div {
      margin-bottom: 5px;
    }
    #weaponSelection {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    button {
      padding: 8px 12px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
    }
    button.active {
      background-color: #0a84ff;
      color: white;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>HP: <span id="playerHp">100</span>%</div>
    <div>Boss HP: <span id="bossHp">300</span></div>
  </div>

  <div id="weaponSelection">
    <button id="swordBtn" class="active">Sword</button>
    <button id="bowBtn">Bow</button>
  </div>

  <canvas id="game" width="400" height="600"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // --- 게임 상태 ---
    const player = {
      x: 200,
      y: 550,
      size: 20,
      color: "cyan",
      hp: 100,
      speed: 5,
      weapon: "sword",
      swordCooldown: 0,
      bowCooldown: 0,
      arrows: [],
    };

    const boss = {
      x: 200,
      y: 100,
      size: 60,
      hp: 300,
      maxHp: 300,
      attackCooldown: 0,
      attackPatternIndex: 0,
      attackTimer: 0,
      colorGradientStops: [
        {pos: 0, color:"red"},
        {pos: 0.15, color:"orange"},
        {pos: 0.3, color:"yellow"},
        {pos: 0.5, color:"green"},
        {pos: 0.65, color:"blue"},
        {pos: 0.8, color:"indigo"},
        {pos: 1, color:"violet"}
      ]
    };

    // 슬라임 속성 예시 (단순화)
    const slimes = [
      {x: 50, y: 300, size: 15, color: "red", hp: 10, type: "fire"},
      {x: 350, y: 350, size: 15, color: "purple", hp: 15, type: "poison"},
      {x: 200, y: 400, size: 15, color: "blue", hp: 12, type: "slow"},
    ];

    // 보스 공격(투사체)
    let bossAttacks = [];

    // 플레이어 공격(검 효과, 화살)
    let swordAttacks = [];
    let bowArrows = [];

    // UI 업데이트 함수
    function updateUI() {
      document.getElementById("playerHp").textContent = player.hp < 0 ? 0 : player.hp;
      document.getElementById("bossHp").textContent = boss.hp < 0 ? 0 : boss.hp;
    }

    // 그리기 함수들
    function drawPlayer() {
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBoss() {
      const grad = ctx.createLinearGradient(boss.x - boss.size, boss.y, boss.x + boss.size, boss.y);
      for (const stop of boss.colorGradientStops) {
        grad.addColorStop(stop.pos, stop.color);
      }
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawSlimes() {
      for (const slime of slimes) {
        ctx.fillStyle = slime.color;
        ctx.beginPath();
        ctx.arc(slime.x, slime.y, slime.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawBossAttacks() {
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      for (const atk of bossAttacks) {
        ctx.beginPath();
        ctx.arc(atk.x, atk.y, atk.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawSwordAttacks() {
      ctx.strokeStyle = "white";
      ctx.lineWidth = 4;
      for (const atk of swordAttacks) {
        ctx.beginPath();
        ctx.moveTo(atk.x1, atk.y1);
        ctx.lineTo(atk.x2, atk.y2);
        ctx.stroke();
      }
    }

    function drawBowArrows() {
      ctx.fillStyle = "yellow";
      for (const arrow of bowArrows) {
        ctx.save();
        ctx.translate(arrow.x, arrow.y);
        ctx.rotate(arrow.angle);
        ctx.beginPath();
        ctx.moveTo(-5, -2);
        ctx.lineTo(10, 0);
        ctx.lineTo(-5, 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    // 이동 처리 (터치, 키보드)
    let moveLeft = false;
    let moveRight = false;

    window.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") moveLeft = true;
      else if (e.key === "ArrowRight") moveRight = true;
      else if (e.key === " ") attack();
    });
    window.addEventListener("keyup", e => {
      if (e.key === "ArrowLeft") moveLeft = false;
      else if (e.key === "ArrowRight") moveRight = false;
    });

    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      if (x < player.x) moveLeft = true;
      else moveRight = true;
      attack();
    });
    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      moveLeft = false;
      moveRight = false;
    });

    // 플레이어 공격 함수
    function attack() {
      if (player.weapon === "sword" && player.swordCooldown <= 0) {
        // 검 공격 (앞으로 짧은 선)
        swordAttacks.push({
          x1: player.x,
          y1: player.y,
          x2: player.x,
          y2: player.y - 40,
          life: 10
        });
        player.swordCooldown = 20; // 쿨다운 프레임
      } else if (player.weapon === "bow" && player.bowCooldown <= 0) {
        // 화살 공격 (위쪽 방향)
        bowArrows.push({
          x: player.x,
          y: player.y - player.size,
          speed: 10,
          angle: -Math.PI/2,
          size: 5,
        });
        player.bowCooldown = 30; // 쿨다운 프레임
      }
    }

    // 충돌 체크
    function circleCollision(x1, y1, r1, x2, y2, r2) {
      const dx = x1 - x2;
      const dy = y1 - y2;
      return (dx * dx + dy * dy) <= (r1 + r2) * (r1 + r2);
    }

    // 보스 공격 함수
    function bossAttack() {
      if (boss.attackCooldown <= 0) {
        let count = Math.floor(Math.random() * 5 + 3);
        for (let i = 0; i < count; i++) {
          bossAttacks.push({
            x: Math.random() * canvas.width,
            y: boss.y + boss.size,
            size: 15,
            speed: 3 + Math.random() * 2
          });
        }
        boss.attackCooldown = 90;
      } else {
        boss.attackCooldown--;
      }
    }

    // 업데이트 함수
    function update() {
      // 플레이어 이동
      if (moveLeft) player.x -= player.speed;
      if (moveRight) player.x += player.speed;
      // 화면 밖 이동 제한
      if (player.x < player.size) player.x = player.size;
      if (player.x > canvas.width - player.size) player.x = canvas.width - player.size;

      // 쿨다운 감소
      if (player.swordCooldown > 0) player.swordCooldown--;
      if (player.bowCooldown > 0) player.bowCooldown--;

      // 검 공격 업데이트
      swordAttacks = swordAttacks.filter(atk => {
        atk.life--;
        if (atk.life <= 0) return false;
        // 보스와 충돌 체크
        if (circleCollision(atk.x2, atk.y2, 10, boss.x, boss.y, boss.size)) {
          boss.hp -= 10;
          return false;
        }
        // 슬라임과 충돌 체크
        for (let i = slimes.length -1; i >= 0; i--) {
          if (circleCollision(atk.x2, atk.y2, 10, slimes[i].x, slimes[i].y, slimes[i].size)) {
            slimes[i].hp -= 10;
            if (slimes[i].hp <= 0) slimes.splice(i,1);
            return false;
          }
        }
        return true;
      });

      // 화살 업데이트
      bowArrows = bowArrows.filter(arrow => {
        arrow.y -= arrow.speed;
        if (arrow.y < -10) return false;
        // 보스와 충돌 체크
        if (circleCollision(arrow.x, arrow.y, arrow.size, boss.x, boss.y, boss.size)) {
          boss.hp -= 8;
          return false;
        }
        // 슬라임과 충돌 체크
        for (let i = slimes.length -1; i >= 0; i--) {
          if (circleCollision(arrow.x, arrow.y, arrow.size, slimes[i].x, slimes[i].y, slimes[i].size)) {
            slimes[i].hp -= 8;
            if (slimes[i].hp <= 0) slimes.splice(i,1);
            return false;
          }
        }
        return true;
      });

      // 보스 공격 업데이트
      bossAttacks = bossAttacks.filter(atk => {
        atk.y += atk.speed;
        if (atk.y > canvas.height + atk.size) return false;
        if (circleCollision(atk.x, atk.y, atk.size, player.x, player.y, player.size)) {
          player.hp -= 5;
          return false;
        }
        return true;
      });

      bossAttack();
      updateUI();
    }

    // 렌더링
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPlayer();
      drawBoss();
      drawSlimes();
      drawBossAttacks();
      drawSwordAttacks();
      drawBowArrows();

      // HP 바 그리기
      // 플레이어
      ctx.fillStyle = "red";
      ctx.fillRect(20, canvas.height - 20, 100, 10);
      ctx.fillStyle = "lime";
      ctx.fillRect(20, canvas.height - 20, player.hp, 10);

      // 보스
      ctx.fillStyle = "darkred";
      ctx.fillRect(boss.x - 50, boss.y - boss.size - 20, 100, 10);
      ctx.fillStyle = "lime";
      ctx.fillRect(boss.x - 50, boss.y - boss.size - 20, (boss.hp / boss.maxHp) * 100, 10);
    }

    // 무기 선택 버튼 이벤트
    const swordBtn = document.getElementById("swordBtn");
    const bowBtn = document.getElementById("bowBtn");

    swordBtn.addEventListener("click", () => {
      player.weapon = "sword";
      swordBtn.classList.add("active");
      bowBtn.classList.remove("active");
    });

    bowBtn.addEventListener("click", () => {
      player.weapon = "bow";
      bowBtn.classList.add("active");
      swordBtn.classList.remove("active");
    });

    // 게임 종료 텍스트
    function gameOver(win) {
      ctx.fillStyle = "white";
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      ctx.fillText(win ? "YOU WIN!" : "GAME OVER", canvas.width / 2, canvas.height / 2);
    }

    // 메인 루프
    function gameLoop() {
      if (player.hp <= 0) {
        gameOver(false);
        return;
      }
      if (boss.hp <= 0) {
        gameOver(true);
        return;
      }
      update();
      render();
      requestAnimationFrame(gameLoop);
    }
      // HP 바 그리기 (간단한 사각형)
      // 플레이어 HP
      ctx.fillStyle = "red";
      ctx.fillRect(10, canvas.height - 20, 200 * (player.hp / 100), 15);
      ctx.strokeStyle = "white";
      ctx.strokeRect(10, canvas.height - 20, 200, 15);

      // 보스 HP
      ctx.fillStyle = "purple";
      ctx.fillRect(canvas.width - 210, 10, 200 * (boss.hp / boss.maxHp), 15);
      ctx.strokeStyle = "white";
      ctx.strokeRect(canvas.width - 210, 10, 200, 15);
    }

    // 게임 루프
    function gameLoop() {
      update();
      render();

      // 게임 오버 체크
      if (player.hp <= 0) {
        alert("게임 오버! 당신은 패배했습니다.");
        window.location.reload();
        return;
      }
      // 보스 처치 체크
      if (boss.hp <= 0) {
        alert("축하합니다! 보스를 처치했습니다.");
        window.location.reload();
        return;
      }

      requestAnimationFrame(gameLoop);
    }

    // 무기 선택 UI 처리
    const swordBtn = document.getElementById("swordBtn");
    const bowBtn = document.getElementById("bowBtn");

    swordBtn.addEventListener("click", () => {
      player.weapon = "sword";
      swordBtn.classList.add("active");
      bowBtn.classList.remove("active");
    });
    bowBtn.addEventListener("click", () => {
      player.weapon = "bow";
      bowBtn.classList.add("active");
      swordBtn.classList.remove("active");
    });

    // 게임 시작
    gameLoop();
  </script>
</body>
</html>

    
