<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Rainbow Slime Boss</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #111;
      border: 2px solid #888;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      z-index: 10;
    }
    #weaponSelect {
      position: absolute;
      top: 80px;
      left: 10px;
      z-index: 10;
    }
    button {
      font-size: 16px;
      margin-right: 8px;
      padding: 6px 12px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>HP: <span id="playerHp">100</span>%</div>
    <div>Boss HP: <span id="bossHp">300</span></div>
  </div>
  <div id="weaponSelect">
    <button id="swordBtn">검</button>
    <button id="bowBtn">활</button>
  </div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // 화면 크기에 맞게 캔버스 리사이즈 (모바일 최적화)
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // 플레이어 객체
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      size: 20,
      color: "cyan",
      hp: 100,
    };

    // 보스 객체
    const boss = {
      x: canvas.width / 2,
      y: 100,
      size: 60,
      hp: 300,
      attackCooldown: 0
    };

    // 무기 클래스
    class Weapon {
      constructor(name, damage, range) {
        this.name = name;
        this.damage = damage;
        this.range = range;
      }
      attack(target) {
        // 단순 거리 판정
        const dx = player.x - target.x;
        const dy = player.y - target.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= this.range + target.size) {
          target.hp -= this.damage;
          if(target.hp < 0) target.hp = 0;
          console.log(`${this.name} 공격! 보스 체력: ${target.hp}`);
        }
      }
    }

    // 무기 인스턴스
    const sword = new Weapon("검", 20, 50);
    const bow = new Weapon("활", 10, 200);

    // 플레이어가 현재 사용하는 무기
    let currentWeapon = sword;

    // 무기 변경 UI 핸들러
    document.getElementById("swordBtn").addEventListener("click", () => {
      currentWeapon = sword;
    });
    document.getElementById("bowBtn").addEventListener("click", () => {
      currentWeapon = bow;
    });

    // 공격 효과 (화살, 검 공격 시 표시)
    let playerAttacks = [];

    // 플레이어 공격 함수
    function playerAttack() {
      currentWeapon.attack(boss);
      // 공격 시 간단히 공격 효과 추가 (화살 or 검 이펙트)
      if(currentWeapon === bow) {
        // 활 공격: 화살 생성, 보스 방향으로 직선 이동
        playerAttacks.push({
          x: player.x,
          y: player.y,
          size: 5,
          speed: 10,
          damage: currentWeapon.damage,
          targetX: boss.x,
          targetY: boss.y
        });
      } else if(currentWeapon === sword) {
        // 검 공격: 근접 범위 이펙트
        // 단순히 잠시 원형 표시 (공격 범위 표시)
        playerAttacks.push({
          x: player.x,
          y: player.y,
          size: 30,
          speed: 0,
          damage: currentWeapon.damage,
          life: 10 // 지속시간
        });
      }
    }

    // 공격 효과 업데이트 및 충돌 처리
    function updatePlayerAttacks() {
      for(let i = playerAttacks.length - 1; i >= 0; i--) {
        let atk = playerAttacks[i];
        if(atk.speed > 0) {
          // 화살 움직임 (직선)
          let dx = atk.targetX - atk.x;
          let dy = atk.targetY - atk.y;
          let dist = Math.sqrt(dx*dx + dy*dy);
          if(dist < atk.speed) {
            atk.x = atk.targetX;
            atk.y = atk.targetY;
          } else {
            atk.x += (dx / dist) * atk.speed;
            atk.y += (dy / dist) * atk.speed;
          }
        } else {
          // 검 공격 지속시간 감소
          atk.life--;
          if(atk.life <= 0) {
            playerAttacks.splice(i, 1);
            continue;
          }
        }

        // 보스와 충돌 판정
        const dx = atk.x - boss.x;
        const dy = atk.y - boss.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if(dist < atk.size + boss.size) {
          boss.hp -= atk.damage;
          if(boss.hp < 0) boss.hp = 0;
          playerAttacks.splice(i, 1);
        }
      }
    }

    // 보스 공격
    let bossAttacks = [];

    function bossAttack() {
      let count = Math.floor(Math.random() * 5 + 3);
      for (let i = 0; i < count; i++) {
        bossAttacks.push({
          x: Math.random() * canvas.width,
          y: boss.y + boss.size,
          size: 15,
          speed: 3 + Math.random() * 2
        });
      }
    }

    // 플레이어 그리기
    function drawPlayer() {
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();
    }

    // 보스 그리기 (무지개 그라데이션)
    function drawBoss() {
      const gradient = ctx.createLinearGradient(boss.x - boss.size, boss.y, boss.x + boss.size, boss.y);
      gradient.addColorStop(0, "red");
      gradient.addColorStop(0.15, "orange");
      gradient.addColorStop(0.3, "yellow");
      gradient.addColorStop(0.5, "green");
      gradient.addColorStop(0.65, "blue");
      gradient.addColorStop(0.8, "indigo");
      gradient.addColorStop(1, "violet");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(boss.x, boss.y, boss.size, 0, Math.PI * 2);
      ctx.fill();
    }

    // 보스 공격 그리기
    function drawBossAttacks() {
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      for (let atk of bossAttacks) {
        ctx.beginPath();
        ctx.arc(atk.x, atk.y, atk.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 플레이어 공격 이펙트 그리기
    function drawPlayerAttacks() {
      ctx.fillStyle = currentWeapon === bow ? "yellow" : "cyan";
      for (let atk of playerAttacks) {
        ctx.beginPath();
        ctx.arc(atk.x, atk.y, atk.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 게임 업데이트
    function update() {
      // 보스 공격 이동
      for (let atk of bossAttacks) {
        atk.y += atk.speed;
      }
      // 화면 밖 공격 제거
      bossAttacks = bossAttacks.filter(atk => atk.y < canvas.height);

      // 보스 공격이 플레이어에 닿으면 데미지
      for (let i = bossAttacks.length - 1; i >= 0; i--) {
        const atk = bossAttacks[i];
        const dx = atk.x - player.x;
        const dy = atk.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < atk.size + player.size) {
          player.hp -= 5;
          bossAttacks.splice(i, 1);
          if(player.hp < 0) player.hp = 0;
        }
      }

      // 보스 공격 쿨다운
      if (boss.attackCooldown <= 0) {
        bossAttack();
        boss.attackCooldown = 90; // 1.5초마다
      } else {
        boss.attackCooldown--;
      }

      updatePlayerAttacks();

      // UI 업데이트
      document.getElementById("playerHp").textContent = player.hp;
      document.getElementById("bossHp").textContent = boss.hp;
    }

    // 화면 그리기
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPlayer();
      drawBoss();
      drawBossAttacks();
      drawPlayerAttacks();
    }

    // 메인 게임 루프
    function gameLoop() {
      update();
      render();
      if (player.hp > 0 && boss.hp > 0) {
        requestAnimationFrame(gameLoop);
      } else {
        ctx.fillStyle = "white";
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillText(player.hp > 0 ? "YOU WIN!" : "GAME OVER", canvas.width / 2, canvas.height / 2);
      }
    }

    // 터치 및 마우스 입력 처리

    // 터치 이동 (드래그)
    let dragging = false;
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      dragging = true;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      player.x = touch.clientX - rect.left;
      player.y = touch.clientY - rect.top;
    });
    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if(dragging) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        player.x = touch.clientX - rect.left;
        player.y = touch.clientY - rect.top;
      }
    });
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      dragging = false;
    });

   
